// Code generated by ent, DO NOT EDIT.

package entgen

import (
	"auth/ent/entgen/authprovider"
	"auth/ent/entgen/authuser"
	"auth/ent/entgen/predicate"
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAuthProvider = "AuthProvider"
	TypeAuthUser     = "AuthUser"
)

// AuthProviderMutation represents an operation that mutates the AuthProvider nodes in the graph.
type AuthProviderMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	created_by    *string
	updated_by    *string
	deleted_by    *string
	user_agent    *string
	ip_address    *string
	name          *string
	display_name  *string
	clearedFields map[string]struct{}
	users         map[string]struct{}
	removedusers  map[string]struct{}
	clearedusers  bool
	done          bool
	oldValue      func(context.Context) (*AuthProvider, error)
	predicates    []predicate.AuthProvider
}

var _ ent.Mutation = (*AuthProviderMutation)(nil)

// authproviderOption allows management of the mutation configuration using functional options.
type authproviderOption func(*AuthProviderMutation)

// newAuthProviderMutation creates new mutation for the AuthProvider entity.
func newAuthProviderMutation(c config, op Op, opts ...authproviderOption) *AuthProviderMutation {
	m := &AuthProviderMutation{
		config:        c,
		op:            op,
		typ:           TypeAuthProvider,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuthProviderID sets the ID field of the mutation.
func withAuthProviderID(id int) authproviderOption {
	return func(m *AuthProviderMutation) {
		var (
			err   error
			once  sync.Once
			value *AuthProvider
		)
		m.oldValue = func(ctx context.Context) (*AuthProvider, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuthProvider.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuthProvider sets the old AuthProvider of the mutation.
func withAuthProvider(node *AuthProvider) authproviderOption {
	return func(m *AuthProviderMutation) {
		m.oldValue = func(context.Context) (*AuthProvider, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuthProviderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuthProviderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entgen: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AuthProvider entities.
func (m *AuthProviderMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuthProviderMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuthProviderMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AuthProvider.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AuthProviderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AuthProviderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AuthProvider entity.
// If the AuthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthProviderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AuthProviderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AuthProviderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AuthProviderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AuthProvider entity.
// If the AuthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthProviderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AuthProviderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AuthProviderMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AuthProviderMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AuthProvider entity.
// If the AuthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthProviderMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AuthProviderMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[authprovider.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AuthProviderMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[authprovider.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AuthProviderMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, authprovider.FieldDeletedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *AuthProviderMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *AuthProviderMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the AuthProvider entity.
// If the AuthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthProviderMutation) OldCreatedBy(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *AuthProviderMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[authprovider.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *AuthProviderMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[authprovider.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *AuthProviderMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, authprovider.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *AuthProviderMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *AuthProviderMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the AuthProvider entity.
// If the AuthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthProviderMutation) OldUpdatedBy(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *AuthProviderMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[authprovider.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *AuthProviderMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[authprovider.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *AuthProviderMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, authprovider.FieldUpdatedBy)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *AuthProviderMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *AuthProviderMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the AuthProvider entity.
// If the AuthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthProviderMutation) OldDeletedBy(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *AuthProviderMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[authprovider.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *AuthProviderMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[authprovider.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *AuthProviderMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, authprovider.FieldDeletedBy)
}

// SetUserAgent sets the "user_agent" field.
func (m *AuthProviderMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *AuthProviderMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the AuthProvider entity.
// If the AuthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthProviderMutation) OldUserAgent(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *AuthProviderMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[authprovider.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *AuthProviderMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[authprovider.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *AuthProviderMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, authprovider.FieldUserAgent)
}

// SetIPAddress sets the "ip_address" field.
func (m *AuthProviderMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *AuthProviderMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the AuthProvider entity.
// If the AuthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthProviderMutation) OldIPAddress(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ClearIPAddress clears the value of the "ip_address" field.
func (m *AuthProviderMutation) ClearIPAddress() {
	m.ip_address = nil
	m.clearedFields[authprovider.FieldIPAddress] = struct{}{}
}

// IPAddressCleared returns if the "ip_address" field was cleared in this mutation.
func (m *AuthProviderMutation) IPAddressCleared() bool {
	_, ok := m.clearedFields[authprovider.FieldIPAddress]
	return ok
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *AuthProviderMutation) ResetIPAddress() {
	m.ip_address = nil
	delete(m.clearedFields, authprovider.FieldIPAddress)
}

// SetName sets the "name" field.
func (m *AuthProviderMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AuthProviderMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AuthProvider entity.
// If the AuthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthProviderMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AuthProviderMutation) ResetName() {
	m.name = nil
}

// SetDisplayName sets the "display_name" field.
func (m *AuthProviderMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *AuthProviderMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the AuthProvider entity.
// If the AuthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthProviderMutation) OldDisplayName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *AuthProviderMutation) ResetDisplayName() {
	m.display_name = nil
}

// AddUserIDs adds the "users" edge to the AuthUser entity by ids.
func (m *AuthProviderMutation) AddUserIDs(ids ...string) {
	if m.users == nil {
		m.users = make(map[string]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the AuthUser entity.
func (m *AuthProviderMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the AuthUser entity was cleared.
func (m *AuthProviderMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the AuthUser entity by IDs.
func (m *AuthProviderMutation) RemoveUserIDs(ids ...string) {
	if m.removedusers == nil {
		m.removedusers = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the AuthUser entity.
func (m *AuthProviderMutation) RemovedUsersIDs() (ids []string) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *AuthProviderMutation) UsersIDs() (ids []string) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *AuthProviderMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// Where appends a list predicates to the AuthProviderMutation builder.
func (m *AuthProviderMutation) Where(ps ...predicate.AuthProvider) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuthProviderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuthProviderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AuthProvider, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuthProviderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuthProviderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AuthProvider).
func (m *AuthProviderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuthProviderMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, authprovider.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, authprovider.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, authprovider.FieldDeletedAt)
	}
	if m.created_by != nil {
		fields = append(fields, authprovider.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, authprovider.FieldUpdatedBy)
	}
	if m.deleted_by != nil {
		fields = append(fields, authprovider.FieldDeletedBy)
	}
	if m.user_agent != nil {
		fields = append(fields, authprovider.FieldUserAgent)
	}
	if m.ip_address != nil {
		fields = append(fields, authprovider.FieldIPAddress)
	}
	if m.name != nil {
		fields = append(fields, authprovider.FieldName)
	}
	if m.display_name != nil {
		fields = append(fields, authprovider.FieldDisplayName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuthProviderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case authprovider.FieldCreatedAt:
		return m.CreatedAt()
	case authprovider.FieldUpdatedAt:
		return m.UpdatedAt()
	case authprovider.FieldDeletedAt:
		return m.DeletedAt()
	case authprovider.FieldCreatedBy:
		return m.CreatedBy()
	case authprovider.FieldUpdatedBy:
		return m.UpdatedBy()
	case authprovider.FieldDeletedBy:
		return m.DeletedBy()
	case authprovider.FieldUserAgent:
		return m.UserAgent()
	case authprovider.FieldIPAddress:
		return m.IPAddress()
	case authprovider.FieldName:
		return m.Name()
	case authprovider.FieldDisplayName:
		return m.DisplayName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuthProviderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case authprovider.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case authprovider.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case authprovider.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case authprovider.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case authprovider.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case authprovider.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case authprovider.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case authprovider.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case authprovider.FieldName:
		return m.OldName(ctx)
	case authprovider.FieldDisplayName:
		return m.OldDisplayName(ctx)
	}
	return nil, fmt.Errorf("unknown AuthProvider field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthProviderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case authprovider.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case authprovider.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case authprovider.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case authprovider.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case authprovider.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case authprovider.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case authprovider.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case authprovider.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case authprovider.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case authprovider.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	}
	return fmt.Errorf("unknown AuthProvider field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuthProviderMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuthProviderMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthProviderMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AuthProvider numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuthProviderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(authprovider.FieldDeletedAt) {
		fields = append(fields, authprovider.FieldDeletedAt)
	}
	if m.FieldCleared(authprovider.FieldCreatedBy) {
		fields = append(fields, authprovider.FieldCreatedBy)
	}
	if m.FieldCleared(authprovider.FieldUpdatedBy) {
		fields = append(fields, authprovider.FieldUpdatedBy)
	}
	if m.FieldCleared(authprovider.FieldDeletedBy) {
		fields = append(fields, authprovider.FieldDeletedBy)
	}
	if m.FieldCleared(authprovider.FieldUserAgent) {
		fields = append(fields, authprovider.FieldUserAgent)
	}
	if m.FieldCleared(authprovider.FieldIPAddress) {
		fields = append(fields, authprovider.FieldIPAddress)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuthProviderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuthProviderMutation) ClearField(name string) error {
	switch name {
	case authprovider.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case authprovider.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case authprovider.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case authprovider.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case authprovider.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case authprovider.FieldIPAddress:
		m.ClearIPAddress()
		return nil
	}
	return fmt.Errorf("unknown AuthProvider nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuthProviderMutation) ResetField(name string) error {
	switch name {
	case authprovider.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case authprovider.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case authprovider.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case authprovider.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case authprovider.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case authprovider.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case authprovider.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case authprovider.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case authprovider.FieldName:
		m.ResetName()
		return nil
	case authprovider.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	}
	return fmt.Errorf("unknown AuthProvider field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuthProviderMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.users != nil {
		edges = append(edges, authprovider.EdgeUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuthProviderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case authprovider.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuthProviderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedusers != nil {
		edges = append(edges, authprovider.EdgeUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuthProviderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case authprovider.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuthProviderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedusers {
		edges = append(edges, authprovider.EdgeUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuthProviderMutation) EdgeCleared(name string) bool {
	switch name {
	case authprovider.EdgeUsers:
		return m.clearedusers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuthProviderMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown AuthProvider unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuthProviderMutation) ResetEdge(name string) error {
	switch name {
	case authprovider.EdgeUsers:
		m.ResetUsers()
		return nil
	}
	return fmt.Errorf("unknown AuthProvider edge %s", name)
}

// AuthUserMutation represents an operation that mutates the AuthUser nodes in the graph.
type AuthUserMutation struct {
	config
	op               Op
	typ              string
	id               *string
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	created_by       *string
	updated_by       *string
	deleted_by       *string
	user_agent       *string
	ip_address       *string
	provider_user_id *string
	team_id          *string
	name             *string
	real_name        *string
	email            *string
	access_token     *string
	refresh_token    *string
	token_type       *string
	expires_at       *time.Time
	scope            *string
	raw_profile      *map[string]interface{}
	clearedFields    map[string]struct{}
	provider         *int
	clearedprovider  bool
	done             bool
	oldValue         func(context.Context) (*AuthUser, error)
	predicates       []predicate.AuthUser
}

var _ ent.Mutation = (*AuthUserMutation)(nil)

// authuserOption allows management of the mutation configuration using functional options.
type authuserOption func(*AuthUserMutation)

// newAuthUserMutation creates new mutation for the AuthUser entity.
func newAuthUserMutation(c config, op Op, opts ...authuserOption) *AuthUserMutation {
	m := &AuthUserMutation{
		config:        c,
		op:            op,
		typ:           TypeAuthUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuthUserID sets the ID field of the mutation.
func withAuthUserID(id string) authuserOption {
	return func(m *AuthUserMutation) {
		var (
			err   error
			once  sync.Once
			value *AuthUser
		)
		m.oldValue = func(ctx context.Context) (*AuthUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuthUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuthUser sets the old AuthUser of the mutation.
func withAuthUser(node *AuthUser) authuserOption {
	return func(m *AuthUserMutation) {
		m.oldValue = func(context.Context) (*AuthUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuthUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuthUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entgen: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AuthUser entities.
func (m *AuthUserMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuthUserMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuthUserMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AuthUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AuthUserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AuthUserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AuthUser entity.
// If the AuthUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthUserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AuthUserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AuthUserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AuthUserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AuthUser entity.
// If the AuthUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthUserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AuthUserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AuthUserMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AuthUserMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AuthUser entity.
// If the AuthUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthUserMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AuthUserMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[authuser.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AuthUserMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[authuser.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AuthUserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, authuser.FieldDeletedAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *AuthUserMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *AuthUserMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the AuthUser entity.
// If the AuthUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthUserMutation) OldCreatedBy(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *AuthUserMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[authuser.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *AuthUserMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[authuser.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *AuthUserMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, authuser.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *AuthUserMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *AuthUserMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the AuthUser entity.
// If the AuthUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthUserMutation) OldUpdatedBy(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *AuthUserMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[authuser.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *AuthUserMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[authuser.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *AuthUserMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, authuser.FieldUpdatedBy)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *AuthUserMutation) SetDeletedBy(s string) {
	m.deleted_by = &s
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *AuthUserMutation) DeletedBy() (r string, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the AuthUser entity.
// If the AuthUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthUserMutation) OldDeletedBy(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *AuthUserMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.clearedFields[authuser.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *AuthUserMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[authuser.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *AuthUserMutation) ResetDeletedBy() {
	m.deleted_by = nil
	delete(m.clearedFields, authuser.FieldDeletedBy)
}

// SetUserAgent sets the "user_agent" field.
func (m *AuthUserMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *AuthUserMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the AuthUser entity.
// If the AuthUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthUserMutation) OldUserAgent(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *AuthUserMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[authuser.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *AuthUserMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[authuser.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *AuthUserMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, authuser.FieldUserAgent)
}

// SetIPAddress sets the "ip_address" field.
func (m *AuthUserMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *AuthUserMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the AuthUser entity.
// If the AuthUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthUserMutation) OldIPAddress(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ClearIPAddress clears the value of the "ip_address" field.
func (m *AuthUserMutation) ClearIPAddress() {
	m.ip_address = nil
	m.clearedFields[authuser.FieldIPAddress] = struct{}{}
}

// IPAddressCleared returns if the "ip_address" field was cleared in this mutation.
func (m *AuthUserMutation) IPAddressCleared() bool {
	_, ok := m.clearedFields[authuser.FieldIPAddress]
	return ok
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *AuthUserMutation) ResetIPAddress() {
	m.ip_address = nil
	delete(m.clearedFields, authuser.FieldIPAddress)
}

// SetProviderID sets the "provider_id" field.
func (m *AuthUserMutation) SetProviderID(i int) {
	m.provider = &i
}

// ProviderID returns the value of the "provider_id" field in the mutation.
func (m *AuthUserMutation) ProviderID() (r int, exists bool) {
	v := m.provider
	if v == nil {
		return
	}
	return *v, true
}

// OldProviderID returns the old "provider_id" field's value of the AuthUser entity.
// If the AuthUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthUserMutation) OldProviderID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProviderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProviderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProviderID: %w", err)
	}
	return oldValue.ProviderID, nil
}

// ResetProviderID resets all changes to the "provider_id" field.
func (m *AuthUserMutation) ResetProviderID() {
	m.provider = nil
}

// SetProviderUserID sets the "provider_user_id" field.
func (m *AuthUserMutation) SetProviderUserID(s string) {
	m.provider_user_id = &s
}

// ProviderUserID returns the value of the "provider_user_id" field in the mutation.
func (m *AuthUserMutation) ProviderUserID() (r string, exists bool) {
	v := m.provider_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProviderUserID returns the old "provider_user_id" field's value of the AuthUser entity.
// If the AuthUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthUserMutation) OldProviderUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProviderUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProviderUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProviderUserID: %w", err)
	}
	return oldValue.ProviderUserID, nil
}

// ResetProviderUserID resets all changes to the "provider_user_id" field.
func (m *AuthUserMutation) ResetProviderUserID() {
	m.provider_user_id = nil
}

// SetTeamID sets the "team_id" field.
func (m *AuthUserMutation) SetTeamID(s string) {
	m.team_id = &s
}

// TeamID returns the value of the "team_id" field in the mutation.
func (m *AuthUserMutation) TeamID() (r string, exists bool) {
	v := m.team_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTeamID returns the old "team_id" field's value of the AuthUser entity.
// If the AuthUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthUserMutation) OldTeamID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeamID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeamID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeamID: %w", err)
	}
	return oldValue.TeamID, nil
}

// ClearTeamID clears the value of the "team_id" field.
func (m *AuthUserMutation) ClearTeamID() {
	m.team_id = nil
	m.clearedFields[authuser.FieldTeamID] = struct{}{}
}

// TeamIDCleared returns if the "team_id" field was cleared in this mutation.
func (m *AuthUserMutation) TeamIDCleared() bool {
	_, ok := m.clearedFields[authuser.FieldTeamID]
	return ok
}

// ResetTeamID resets all changes to the "team_id" field.
func (m *AuthUserMutation) ResetTeamID() {
	m.team_id = nil
	delete(m.clearedFields, authuser.FieldTeamID)
}

// SetName sets the "name" field.
func (m *AuthUserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AuthUserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AuthUser entity.
// If the AuthUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthUserMutation) OldName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *AuthUserMutation) ClearName() {
	m.name = nil
	m.clearedFields[authuser.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *AuthUserMutation) NameCleared() bool {
	_, ok := m.clearedFields[authuser.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *AuthUserMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, authuser.FieldName)
}

// SetRealName sets the "real_name" field.
func (m *AuthUserMutation) SetRealName(s string) {
	m.real_name = &s
}

// RealName returns the value of the "real_name" field in the mutation.
func (m *AuthUserMutation) RealName() (r string, exists bool) {
	v := m.real_name
	if v == nil {
		return
	}
	return *v, true
}

// OldRealName returns the old "real_name" field's value of the AuthUser entity.
// If the AuthUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthUserMutation) OldRealName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRealName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRealName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRealName: %w", err)
	}
	return oldValue.RealName, nil
}

// ClearRealName clears the value of the "real_name" field.
func (m *AuthUserMutation) ClearRealName() {
	m.real_name = nil
	m.clearedFields[authuser.FieldRealName] = struct{}{}
}

// RealNameCleared returns if the "real_name" field was cleared in this mutation.
func (m *AuthUserMutation) RealNameCleared() bool {
	_, ok := m.clearedFields[authuser.FieldRealName]
	return ok
}

// ResetRealName resets all changes to the "real_name" field.
func (m *AuthUserMutation) ResetRealName() {
	m.real_name = nil
	delete(m.clearedFields, authuser.FieldRealName)
}

// SetEmail sets the "email" field.
func (m *AuthUserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *AuthUserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the AuthUser entity.
// If the AuthUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthUserMutation) OldEmail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *AuthUserMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[authuser.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *AuthUserMutation) EmailCleared() bool {
	_, ok := m.clearedFields[authuser.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *AuthUserMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, authuser.FieldEmail)
}

// SetAccessToken sets the "access_token" field.
func (m *AuthUserMutation) SetAccessToken(s string) {
	m.access_token = &s
}

// AccessToken returns the value of the "access_token" field in the mutation.
func (m *AuthUserMutation) AccessToken() (r string, exists bool) {
	v := m.access_token
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessToken returns the old "access_token" field's value of the AuthUser entity.
// If the AuthUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthUserMutation) OldAccessToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessToken: %w", err)
	}
	return oldValue.AccessToken, nil
}

// ResetAccessToken resets all changes to the "access_token" field.
func (m *AuthUserMutation) ResetAccessToken() {
	m.access_token = nil
}

// SetRefreshToken sets the "refresh_token" field.
func (m *AuthUserMutation) SetRefreshToken(s string) {
	m.refresh_token = &s
}

// RefreshToken returns the value of the "refresh_token" field in the mutation.
func (m *AuthUserMutation) RefreshToken() (r string, exists bool) {
	v := m.refresh_token
	if v == nil {
		return
	}
	return *v, true
}

// OldRefreshToken returns the old "refresh_token" field's value of the AuthUser entity.
// If the AuthUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthUserMutation) OldRefreshToken(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefreshToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefreshToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefreshToken: %w", err)
	}
	return oldValue.RefreshToken, nil
}

// ClearRefreshToken clears the value of the "refresh_token" field.
func (m *AuthUserMutation) ClearRefreshToken() {
	m.refresh_token = nil
	m.clearedFields[authuser.FieldRefreshToken] = struct{}{}
}

// RefreshTokenCleared returns if the "refresh_token" field was cleared in this mutation.
func (m *AuthUserMutation) RefreshTokenCleared() bool {
	_, ok := m.clearedFields[authuser.FieldRefreshToken]
	return ok
}

// ResetRefreshToken resets all changes to the "refresh_token" field.
func (m *AuthUserMutation) ResetRefreshToken() {
	m.refresh_token = nil
	delete(m.clearedFields, authuser.FieldRefreshToken)
}

// SetTokenType sets the "token_type" field.
func (m *AuthUserMutation) SetTokenType(s string) {
	m.token_type = &s
}

// TokenType returns the value of the "token_type" field in the mutation.
func (m *AuthUserMutation) TokenType() (r string, exists bool) {
	v := m.token_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenType returns the old "token_type" field's value of the AuthUser entity.
// If the AuthUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthUserMutation) OldTokenType(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenType: %w", err)
	}
	return oldValue.TokenType, nil
}

// ClearTokenType clears the value of the "token_type" field.
func (m *AuthUserMutation) ClearTokenType() {
	m.token_type = nil
	m.clearedFields[authuser.FieldTokenType] = struct{}{}
}

// TokenTypeCleared returns if the "token_type" field was cleared in this mutation.
func (m *AuthUserMutation) TokenTypeCleared() bool {
	_, ok := m.clearedFields[authuser.FieldTokenType]
	return ok
}

// ResetTokenType resets all changes to the "token_type" field.
func (m *AuthUserMutation) ResetTokenType() {
	m.token_type = nil
	delete(m.clearedFields, authuser.FieldTokenType)
}

// SetExpiresAt sets the "expires_at" field.
func (m *AuthUserMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *AuthUserMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the AuthUser entity.
// If the AuthUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthUserMutation) OldExpiresAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *AuthUserMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[authuser.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *AuthUserMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[authuser.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *AuthUserMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, authuser.FieldExpiresAt)
}

// SetScope sets the "scope" field.
func (m *AuthUserMutation) SetScope(s string) {
	m.scope = &s
}

// Scope returns the value of the "scope" field in the mutation.
func (m *AuthUserMutation) Scope() (r string, exists bool) {
	v := m.scope
	if v == nil {
		return
	}
	return *v, true
}

// OldScope returns the old "scope" field's value of the AuthUser entity.
// If the AuthUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthUserMutation) OldScope(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScope is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScope requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScope: %w", err)
	}
	return oldValue.Scope, nil
}

// ClearScope clears the value of the "scope" field.
func (m *AuthUserMutation) ClearScope() {
	m.scope = nil
	m.clearedFields[authuser.FieldScope] = struct{}{}
}

// ScopeCleared returns if the "scope" field was cleared in this mutation.
func (m *AuthUserMutation) ScopeCleared() bool {
	_, ok := m.clearedFields[authuser.FieldScope]
	return ok
}

// ResetScope resets all changes to the "scope" field.
func (m *AuthUserMutation) ResetScope() {
	m.scope = nil
	delete(m.clearedFields, authuser.FieldScope)
}

// SetRawProfile sets the "raw_profile" field.
func (m *AuthUserMutation) SetRawProfile(value map[string]interface{}) {
	m.raw_profile = &value
}

// RawProfile returns the value of the "raw_profile" field in the mutation.
func (m *AuthUserMutation) RawProfile() (r map[string]interface{}, exists bool) {
	v := m.raw_profile
	if v == nil {
		return
	}
	return *v, true
}

// OldRawProfile returns the old "raw_profile" field's value of the AuthUser entity.
// If the AuthUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthUserMutation) OldRawProfile(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRawProfile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRawProfile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRawProfile: %w", err)
	}
	return oldValue.RawProfile, nil
}

// ClearRawProfile clears the value of the "raw_profile" field.
func (m *AuthUserMutation) ClearRawProfile() {
	m.raw_profile = nil
	m.clearedFields[authuser.FieldRawProfile] = struct{}{}
}

// RawProfileCleared returns if the "raw_profile" field was cleared in this mutation.
func (m *AuthUserMutation) RawProfileCleared() bool {
	_, ok := m.clearedFields[authuser.FieldRawProfile]
	return ok
}

// ResetRawProfile resets all changes to the "raw_profile" field.
func (m *AuthUserMutation) ResetRawProfile() {
	m.raw_profile = nil
	delete(m.clearedFields, authuser.FieldRawProfile)
}

// ClearProvider clears the "provider" edge to the AuthProvider entity.
func (m *AuthUserMutation) ClearProvider() {
	m.clearedprovider = true
	m.clearedFields[authuser.FieldProviderID] = struct{}{}
}

// ProviderCleared reports if the "provider" edge to the AuthProvider entity was cleared.
func (m *AuthUserMutation) ProviderCleared() bool {
	return m.clearedprovider
}

// ProviderIDs returns the "provider" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProviderID instead. It exists only for internal usage by the builders.
func (m *AuthUserMutation) ProviderIDs() (ids []int) {
	if id := m.provider; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvider resets all changes to the "provider" edge.
func (m *AuthUserMutation) ResetProvider() {
	m.provider = nil
	m.clearedprovider = false
}

// Where appends a list predicates to the AuthUserMutation builder.
func (m *AuthUserMutation) Where(ps ...predicate.AuthUser) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuthUserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuthUserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AuthUser, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuthUserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuthUserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AuthUser).
func (m *AuthUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuthUserMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.created_at != nil {
		fields = append(fields, authuser.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, authuser.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, authuser.FieldDeletedAt)
	}
	if m.created_by != nil {
		fields = append(fields, authuser.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, authuser.FieldUpdatedBy)
	}
	if m.deleted_by != nil {
		fields = append(fields, authuser.FieldDeletedBy)
	}
	if m.user_agent != nil {
		fields = append(fields, authuser.FieldUserAgent)
	}
	if m.ip_address != nil {
		fields = append(fields, authuser.FieldIPAddress)
	}
	if m.provider != nil {
		fields = append(fields, authuser.FieldProviderID)
	}
	if m.provider_user_id != nil {
		fields = append(fields, authuser.FieldProviderUserID)
	}
	if m.team_id != nil {
		fields = append(fields, authuser.FieldTeamID)
	}
	if m.name != nil {
		fields = append(fields, authuser.FieldName)
	}
	if m.real_name != nil {
		fields = append(fields, authuser.FieldRealName)
	}
	if m.email != nil {
		fields = append(fields, authuser.FieldEmail)
	}
	if m.access_token != nil {
		fields = append(fields, authuser.FieldAccessToken)
	}
	if m.refresh_token != nil {
		fields = append(fields, authuser.FieldRefreshToken)
	}
	if m.token_type != nil {
		fields = append(fields, authuser.FieldTokenType)
	}
	if m.expires_at != nil {
		fields = append(fields, authuser.FieldExpiresAt)
	}
	if m.scope != nil {
		fields = append(fields, authuser.FieldScope)
	}
	if m.raw_profile != nil {
		fields = append(fields, authuser.FieldRawProfile)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuthUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case authuser.FieldCreatedAt:
		return m.CreatedAt()
	case authuser.FieldUpdatedAt:
		return m.UpdatedAt()
	case authuser.FieldDeletedAt:
		return m.DeletedAt()
	case authuser.FieldCreatedBy:
		return m.CreatedBy()
	case authuser.FieldUpdatedBy:
		return m.UpdatedBy()
	case authuser.FieldDeletedBy:
		return m.DeletedBy()
	case authuser.FieldUserAgent:
		return m.UserAgent()
	case authuser.FieldIPAddress:
		return m.IPAddress()
	case authuser.FieldProviderID:
		return m.ProviderID()
	case authuser.FieldProviderUserID:
		return m.ProviderUserID()
	case authuser.FieldTeamID:
		return m.TeamID()
	case authuser.FieldName:
		return m.Name()
	case authuser.FieldRealName:
		return m.RealName()
	case authuser.FieldEmail:
		return m.Email()
	case authuser.FieldAccessToken:
		return m.AccessToken()
	case authuser.FieldRefreshToken:
		return m.RefreshToken()
	case authuser.FieldTokenType:
		return m.TokenType()
	case authuser.FieldExpiresAt:
		return m.ExpiresAt()
	case authuser.FieldScope:
		return m.Scope()
	case authuser.FieldRawProfile:
		return m.RawProfile()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuthUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case authuser.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case authuser.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case authuser.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case authuser.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case authuser.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case authuser.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case authuser.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case authuser.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case authuser.FieldProviderID:
		return m.OldProviderID(ctx)
	case authuser.FieldProviderUserID:
		return m.OldProviderUserID(ctx)
	case authuser.FieldTeamID:
		return m.OldTeamID(ctx)
	case authuser.FieldName:
		return m.OldName(ctx)
	case authuser.FieldRealName:
		return m.OldRealName(ctx)
	case authuser.FieldEmail:
		return m.OldEmail(ctx)
	case authuser.FieldAccessToken:
		return m.OldAccessToken(ctx)
	case authuser.FieldRefreshToken:
		return m.OldRefreshToken(ctx)
	case authuser.FieldTokenType:
		return m.OldTokenType(ctx)
	case authuser.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case authuser.FieldScope:
		return m.OldScope(ctx)
	case authuser.FieldRawProfile:
		return m.OldRawProfile(ctx)
	}
	return nil, fmt.Errorf("unknown AuthUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case authuser.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case authuser.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case authuser.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case authuser.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case authuser.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case authuser.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case authuser.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case authuser.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case authuser.FieldProviderID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProviderID(v)
		return nil
	case authuser.FieldProviderUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProviderUserID(v)
		return nil
	case authuser.FieldTeamID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeamID(v)
		return nil
	case authuser.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case authuser.FieldRealName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRealName(v)
		return nil
	case authuser.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case authuser.FieldAccessToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessToken(v)
		return nil
	case authuser.FieldRefreshToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefreshToken(v)
		return nil
	case authuser.FieldTokenType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenType(v)
		return nil
	case authuser.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case authuser.FieldScope:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScope(v)
		return nil
	case authuser.FieldRawProfile:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRawProfile(v)
		return nil
	}
	return fmt.Errorf("unknown AuthUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuthUserMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuthUserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AuthUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuthUserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(authuser.FieldDeletedAt) {
		fields = append(fields, authuser.FieldDeletedAt)
	}
	if m.FieldCleared(authuser.FieldCreatedBy) {
		fields = append(fields, authuser.FieldCreatedBy)
	}
	if m.FieldCleared(authuser.FieldUpdatedBy) {
		fields = append(fields, authuser.FieldUpdatedBy)
	}
	if m.FieldCleared(authuser.FieldDeletedBy) {
		fields = append(fields, authuser.FieldDeletedBy)
	}
	if m.FieldCleared(authuser.FieldUserAgent) {
		fields = append(fields, authuser.FieldUserAgent)
	}
	if m.FieldCleared(authuser.FieldIPAddress) {
		fields = append(fields, authuser.FieldIPAddress)
	}
	if m.FieldCleared(authuser.FieldTeamID) {
		fields = append(fields, authuser.FieldTeamID)
	}
	if m.FieldCleared(authuser.FieldName) {
		fields = append(fields, authuser.FieldName)
	}
	if m.FieldCleared(authuser.FieldRealName) {
		fields = append(fields, authuser.FieldRealName)
	}
	if m.FieldCleared(authuser.FieldEmail) {
		fields = append(fields, authuser.FieldEmail)
	}
	if m.FieldCleared(authuser.FieldRefreshToken) {
		fields = append(fields, authuser.FieldRefreshToken)
	}
	if m.FieldCleared(authuser.FieldTokenType) {
		fields = append(fields, authuser.FieldTokenType)
	}
	if m.FieldCleared(authuser.FieldExpiresAt) {
		fields = append(fields, authuser.FieldExpiresAt)
	}
	if m.FieldCleared(authuser.FieldScope) {
		fields = append(fields, authuser.FieldScope)
	}
	if m.FieldCleared(authuser.FieldRawProfile) {
		fields = append(fields, authuser.FieldRawProfile)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuthUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuthUserMutation) ClearField(name string) error {
	switch name {
	case authuser.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case authuser.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case authuser.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case authuser.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case authuser.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case authuser.FieldIPAddress:
		m.ClearIPAddress()
		return nil
	case authuser.FieldTeamID:
		m.ClearTeamID()
		return nil
	case authuser.FieldName:
		m.ClearName()
		return nil
	case authuser.FieldRealName:
		m.ClearRealName()
		return nil
	case authuser.FieldEmail:
		m.ClearEmail()
		return nil
	case authuser.FieldRefreshToken:
		m.ClearRefreshToken()
		return nil
	case authuser.FieldTokenType:
		m.ClearTokenType()
		return nil
	case authuser.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	case authuser.FieldScope:
		m.ClearScope()
		return nil
	case authuser.FieldRawProfile:
		m.ClearRawProfile()
		return nil
	}
	return fmt.Errorf("unknown AuthUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuthUserMutation) ResetField(name string) error {
	switch name {
	case authuser.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case authuser.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case authuser.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case authuser.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case authuser.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case authuser.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case authuser.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case authuser.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case authuser.FieldProviderID:
		m.ResetProviderID()
		return nil
	case authuser.FieldProviderUserID:
		m.ResetProviderUserID()
		return nil
	case authuser.FieldTeamID:
		m.ResetTeamID()
		return nil
	case authuser.FieldName:
		m.ResetName()
		return nil
	case authuser.FieldRealName:
		m.ResetRealName()
		return nil
	case authuser.FieldEmail:
		m.ResetEmail()
		return nil
	case authuser.FieldAccessToken:
		m.ResetAccessToken()
		return nil
	case authuser.FieldRefreshToken:
		m.ResetRefreshToken()
		return nil
	case authuser.FieldTokenType:
		m.ResetTokenType()
		return nil
	case authuser.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case authuser.FieldScope:
		m.ResetScope()
		return nil
	case authuser.FieldRawProfile:
		m.ResetRawProfile()
		return nil
	}
	return fmt.Errorf("unknown AuthUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuthUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.provider != nil {
		edges = append(edges, authuser.EdgeProvider)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuthUserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case authuser.EdgeProvider:
		if id := m.provider; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuthUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuthUserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuthUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedprovider {
		edges = append(edges, authuser.EdgeProvider)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuthUserMutation) EdgeCleared(name string) bool {
	switch name {
	case authuser.EdgeProvider:
		return m.clearedprovider
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuthUserMutation) ClearEdge(name string) error {
	switch name {
	case authuser.EdgeProvider:
		m.ClearProvider()
		return nil
	}
	return fmt.Errorf("unknown AuthUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuthUserMutation) ResetEdge(name string) error {
	switch name {
	case authuser.EdgeProvider:
		m.ResetProvider()
		return nil
	}
	return fmt.Errorf("unknown AuthUser edge %s", name)
}
